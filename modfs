#! /bin/sh
################################################################################
#                                                                              #
# Modify root file system directly at an AVM FRITZ!Box router device           #
#                                                                              #
# Copyright (C) 2014 P.Haemmerlein (http://www.yourfritz.de)                   #
#                                                                              #
# This program is free software; you can redistribute it and/or                #
# modify it under the terms of the GNU General Public License                  #
# as published by the Free Software Foundation; either version 2               #
# of the License, or (at your option) any later version.                       #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License under                                             #
# http://www.gnu.org/licenses/gpl-2.0.html                                     #
# for more details.                                                            #
#                                                                              #
# "FRITZ!Box" and "FRITZ!" are registered word marks and "AVM" is a registered #
# word and figurative mark of:                                                 #
# AVM Computersysteme Vertriebs GmbH, 10559, Berlin, DE.                       #
#                                                                              #
################################################################################
#
# AVM "constants"
#
# procfs of MTD driver
procmtd="/proc/mtd" 
# device name of MTD partition for access with character oriented I/O
mtdprefix="mtd" 
# device name of MTD partitions for access with block oriented I/O
mtdblockname="mtdblock" 
# prefix for inactive partition names
reservedprefix="reserved-" 
# name of kernel partition
kernelname="kernel" 
# name of file system partition
filesystemname="filesystem" 
# name of the partition with NAND flash available to the user
nandname="nand-filesystem" 
# environment file name within the TFFS procfs
envpathname="/proc/sys/urlader/environment" 
# variable used to switch between boot time systems
fsvarname="linux_fs_start" 
# hardware revision variable name
hwrevname="HWRevision" 
# supported hardware revisions
# 3370, 7362SL, 7490
hwrevs_supported="175 185 203" 
# AVM's binary to modify the NAND based partitions (busybox has it's own tools, but not ooB on a device with original firmware)
update_kernel_binary="/sbin/update_kernel" 
# where is the wrapper mounted at the running system ?
wrapperdir="/wrapper" 
# the file name of the root file system image
rootfsname="filesystem_core.squashfs" 
# the name of a firmware image, it will be renamed during download
firmwarestoragename="firmware.image" 
# the wrapper file system image name within a firmware image
firmware_filesystem_image="./var/tmp/filesystem.image" 
# the name of the file, which can be used to determine the version of the system within a squashfs image
versionfilename="/etc/version" 
# the name of the shell on the box
shl="/bin/sh" 
#
# the correct FTP download path is model and version dependent
# one path entry is required for every supported hardware revision (ftp_path_${hwrev})
#
ftp_server="ftp.avm.de"
ftp_path_185="/fritz.box/fritzbox.7490/firmware/deutsch/FRITZ.Box_7490.\$version.image"
ftp_path_203="/fritz.box/fritzbox.7362_sl/firmware/deutsch/FRITZ.Box_7362_SL.\$version.image"
#
# some more values which have to be changed, if AVM modifies its firmware 
#
# 128MB ext3 image plus 5 percent
free_space_for_unpack="134M" 
# 32 MB (23 MB at this time) for packed and double space for unpacked image
free_space_for_unpack_tmpfs="96M" 
# even with a small amount of RAM at all, there should be a minimum of free space
free_space_at_tmpfs="24M" 
# that's really low on space, better restart the box again
warning_space_at_tmpfs="10M" 
# one more time the space needed for our ext3 container + 5%
free_space_at_nand="134M" 
# the estimated space needed to store an extracted squashfs image at NAND
warning_space_at_nand="64M" 
# the estimated space needed to download a firmware image from the FTP server
download_space_needed="32M" 
# the estimated space needed to extract a wrapper file system from a firmware image
extract_space_needed="32M" 
# the "normal" base for temporary files and directories
tmpfsbasedir="/var/tmp" 
# known native file system types, we can use them without a container
nativefilesystems="tmpfs ext2 ext3 ext4 yaffs2" 
#
# error codes
#
#  32 - different MD5 hashes for kernel MTDs
#  33 - unable to find kernel MTD
#  34 - unable to find alternative kernel MTD
#  35 - missing linux_fs_start at environment
#  36 - unsupported hardware revision
#  37 - system modified already, restart needed
#  38 - specified squashfs source file not found
#  39 - unable to extract wrapper image from firmware archive
#  40 - unable to mount wrapper file system
#  41 - unable to copy root image from wrapper
#  42 - unable to download firmware image from manufacturer
#  43 - error downloading firmware image (file size is 0)
#  44 - error copying kernel image to alternative partition
#  45 - error copying wrapper file system to alternative partition
#  46 - unknown error copying running system to inactive partitions
#  47 - unable to get hardware revision
#  48 - unable to find file system MTD partition
#  49 - unable to find alternative file system MTD partition
#  50 - not enough free space available at tmpfs
#  51 - unable to find free space for unpacking of squashfs
#  52 - unable to find free space for squashfs extraction from image
#  53 - error saving permanent copy of source squashfs image
#  54 - error unpacking loopback device image
#  55 - error mounting loopback device image
#  56 - error unmounting loopback device image
#  57 - error removing loopback device image
#  58 - not enough free space on any storage volume
#  66 - the message file was not found after fallback to 'en'
# 127 - internal error
#
# our "internal" constants
#
bindirname="bin"
localedirname="locale"
filesdirname="files"
scriptdirname="modscripts"
tmpdirbase="/var/tmp"
packedpartition="128MB_ext3.gz"
squashfsdirname="squashfs-root"
showprogress=0
msgtext_clearscreen="\x1B[2J\x1B[0;0H"
msgtext_normal="\x1B[0m"
msgtext_bold="\x1B[1m"
msgtext_error="\x1B[1;31m"
msgtext_ok="\x1B[1;32m"
msgtext_warning="\x1B[1;33m"
msgtext_highlight="\x1B[1;34m"
msgtext_CR="\r\x1B[K"
#
# name and relative path of squashfs tools
#
sq3_pack="\$(bindir)/mksquashfs"
sq3_unpack="\$(bindir)/unsquashfs"
#
# universal functions
#
# check, if a list contains an item and return its index (based on 1)
# $1 - the item to look for (needle)
# $2 - the haystack
#
index_of_item()
{
	local item i=0
	for item in $2; do
		let i+=1
		[ x"$1" == x"$item" ] && echo $i && return 0
	done
	return 1
}
#
# get binaries subdirectory name
#
bindir() { echo "$scriptpath/$bindirname/$(get_hardware_revision)"; }
#
# get locale subdirectory name
#
localedir() { echo "$scriptpath/$localedirname"; }
#
# get files subdirectory name
#
filesdir() { echo "$scriptpath/$filesdirname"; }
#
# remove temporary file
# $1 - file name
#
remove_temp_file()
{
	[ -z "$1" ] && return 127
	[ ${#1} -lt 10 ] && return 127
	rm "$1" 2>/dev/null
	sed -e "\|^rm *$1\$|d" -i $tempfilelist
	return 0
}
#
# remove directory and its reference from cleanup list too
# $1 - directory to remove
#
remove_directory()
{
	local dir="$1" newlist=""
	[ ${#1} -lt 10 ] && return 127
	rm -r $dir 2>/dev/null
	sed -e "\|^rm -r *$dir\$|d" -i $tempfilelist
	return 0
}
#
# get temporary directory name
#
get_temp_dir() 
{
	local name="$tmpdirbase/$$_$(date +%s)"
	mkdir -p "$name"
	echo "rm -r $name" >>$tempfilelist
	echo "$name"
	return 0
}
#
# get temporary file name
# $1 - optional base directory name
#
get_temp_file() 
{ 
	local name="$1" dir out
	dir="$(get_temp_dir)"
	[ -z "$name" ] && out="$dir/$(date +%s)" || out="$dir/$name"
	echo "rm $out" >>$tempfilelist
	echo "$out"
	return 0
}
#
# get next system index from environment
#
get_system_switch() { sed -n -e "s/^$fsvarname\t\([01]\)/\1/p" $envpathname; }
#
# get hardware revision from environment (it has not to be a number !)
#
get_hardware_revision() { sed -n -e "s/^$hwrevname\t\(.*\)/\1/p" $envpathname; }
#
# check, if the specified hardware revision is supported 
# $1 - hardware revision
#
check_hardware_revision() { return $(index_of_item "$1" "$hwrevs_supported"); }
#
# check MTD "name"
# $1 - MTD index number
# $2 - expected MTD name from /proc/mtd
#
check_mtd() { grep "$mtdprefix$1: [0-9a-f]* [0-9a-f]* \"\($reservedprefix\)*$2\"" $procmtd; }
#
# get MTD number by name
# $1 - requested MTD partition name
#
get_mtd_by_name() { sed -n -e "s|$mtdprefix\([0-9]\{1,2\}\): [0-9a-f]\{8\} [0-9a-f]\{8\} \"$1\"|\1|p" $procmtd; }
#
# get MTD name by number
# $1 - requested MTD partition number
#
get_mtd_by_number() { sed -n -e "s|$mtdprefix$1: [0-9a-f]\{8\} [0-9a-f]\{8\} \"\(.*\)\"|\1|p" $procmtd; }
#
# build MTD partition groups
#
build_partitions()
{
	local g1 g2
	g1=$(get_mtd_by_name $kernelname):$(get_mtd_by_name $filesystemname)
	g2=$(get_mtd_by_name $reservedprefix$kernelname):$(get_mtd_by_name $reservedprefix$filesystemname)
	if [ ${g1:0:1} -lt ${g2:0:1} ]; then
		echo "$g1 $g2"
	else
		echo "$g2 $g1"
	fi
}
#
# convert string to upper case
# $@ - string(s) to convert
#
uppercase() { echo "$@" | tr 'abcdefghijklmnopqrstuvwxyzäöü' 'ABCDEFGHIJKLMNOPQRSTUVWXYZÄÖÜ'; }
#
# get localized strings (to make it easier for german users)
# - the message text may contain the macros '%{error}', '%{ok}', '%{warning}' and 
#   '%{normal}' to change text color
# - to insert variable parts into the text, the 'printf' command will be used with
#   the specified parameters (shifted two times to remove our own arguments)
# $1 - language index (ISO 639-1 code)
# $2 - message id
# $3-$n - values to substitute
#
get_localized()
{
	local lang=$1 lcfile=$(localedir)/$lang msgno=$2 rc=0 msg
	shift 2
	msg=$(sed -n -e "/^$msgno=/s/^[0-9]*=\(.*\)/\1/p" $lcfile | sed -e "s/%{error}/\${msgtext_error}/g" | sed -e "s/%{ok}/\${msgtext_ok}/g" | sed -e "s/%{warning}/\${msgtext_warning}/g" | sed -e "s/%{bold}/\${msgtext_bold}/g" | sed -e "s/%{normal}/\${msgtext_normal}/g" | sed -e "s/%{highlight}/\${msgtext_highlight}/g")
	if [ ${#msg} -eq 0 ]; then
		echo "The specified message number $msgno was not found at the language file for '$lang'." 1>&2
		rc=1
	else
        eval "printf \"$msg\" "$@""
	fi
	return $rc
}
#
# get a yes or no decision from the user
# $1 - default answer to assume, if only return is pressed
# $2 - the question to display first
# - to avoid a default answer (return key), use any other default than 'y' or 'n'
#
ask_yes_or_no()
{
	local def=$1 yes no p_yes p_no answer nl prompt="$2"
	yes=$(get_localized $lang 129)
	no=$(get_localized $lang 130)
	p_yes=$yes
	p_no=$no
	if [ $def == n ]; then
		p_no=$(uppercase $no)
	else
		if [ $def == y ]; then
			p_yes=$(uppercase $yes)
		fi
	fi
	# 1 -eq 1 is better than 'true', because 'true' is not an ash builtin in every case
	while [ 1 -eq 1 ]; do
		while read -n 10 -s -t 1; do :; done
		echo -ne "$prompt" 1>&2
		read -n 1 -s -p " ($p_yes/$p_no) " answer 1>&2
		nl="$answer\n"
		[ ${#answer} -eq 0 ] && answer=$def && nl="\n"
		if [ $answer == $(uppercase $yes) -o $answer == $yes ]; then
			echo -n 'Y'
			echo -e -n "$nl" 1>&2
			return 0
		else
			if [ $answer == $(uppercase $no) -o $answer == $no ]; then
				echo -n  'N'
				echo -e -n "$nl" 1>&2
				return 0
			else
				echo -e "$selection\n$(get_localized $lang 128)" 1>&2
			fi
		fi
	done
	return 1
}
#
# show progress messages on console
# - output will be written to stderr
# $1 - message type
#      1 - CR + show text without LF
#      2 - show text without LF
#      3 - show text with LF
#      4 - show text with LF in front of it and at the end
# $2 - message id to get localized text version
#
progress()
{
	local msg mode=$1
	shift
	msg="$(get_localized $lang "$@")"
	if [ $mode -eq 1 ]; then
		echo -ne "$msgtext_CR$msg" 1>&2
	else
		if [ $mode -eq 2 ]; then
			echo -ne "$msg" 1>&2
		else
			if [ $mode -eq 3 ]; then
				echo -ne "$msg\n" 1>&2
			else
				if [ $mode -eq 4 ]; then
					echo -ne "\n$msg\n"
				fi
			fi
		fi
	fi
	return
}
#
# check next system against running
#
is_switched()
{
	local nxt kernel filesys kname fname switched=1
	nxt=$(get_system_switch)
	set -- $(build_partitions)
	[ $nxt -gt 0 ] && shift
	kernel=${1%:*}
	filesys=${1#*:}
	kname="$(get_mtd_by_number $kernel)"
	fname="$(get_mtd_by_number $filesys)"
	[ "${kname:0:${#reservedprefix}}" == "$reservedprefix" ] && switched=0
	return $switched
}
#
# compare kernel checksums to make sure, the systems are identical
# $1 and $2 have to be the MTD numbers of the two kernel images
#
check_kernels()
{
	local rc=0
	if [ ${#1} -eq 0 -o ${#2} -eq 0 ];then
		rc=127
	else
		hash0=$(md5sum /dev/$mtdblockname$1 | sed -n -e 's/^\([0-9a-f]*\).*/\1/p')
		hash1=$(md5sum /dev/$mtdblockname$2 | sed -n -e 's/^\([0-9a-f]*\).*/\1/p')
		if [ $hash0 != $hash1 ]; then
			rc=32
		fi
	fi
	return $rc
}
#
# call mksquashfs utility after hash check for the executable
#
sq3_mksquashfs()
{
	local rc=0 binary
	binary="$(eval echo $sq3_pack)"
	$binary "$@"
	rc=$?
	return $rc
}
#
# call unsquashfs utility after hash check dor the executable
#
sq3_unsquashfs()
{
	local rc=0 binary
	binary="$(eval echo $sq3_unpack)"
	$binary "$@"
	rc=$?
	return $rc
}
#
# switch system selection variable to other value
#
switch_system() { echo $fsvarname $(( ( $(get_system_switch) + 1 ) % 2 )) >$envpathname; }
#
# switch next boot time selection to specified system, if action is really needed
# $1 - 'running' / 'alternative' to switch to the specified system based on the running version
#
switch_system_to()
{
	local next
	next=$(get_system_switch)
	if is_switched; then
		if [ x"$1" == xcurrent ]; then
			switch_system
		fi
	else
		if [ x"$1" == xalternative ]; then
			switch_system
		fi
	fi
	return 0
}
#
# copy kernel image to alternative partition
#
copy_kernel_image()
{
	local src target rc
	src=$(get_mtd_by_name $kernelname)
	target=$(get_mtd_by_name $reservedprefix$kernelname)
	$update_kernel_binary -i /dev/$mtdprefix$src -o /dev/$mtdprefix$target >/dev/null 2>&1
	rc=$?
	return $rc
}
#
# copy wrapper file system to alternative partition
#
copy_filesystem()
{
	local tmp target rc
	src=$(get_mtd_by_name $filesystemname)
	target=$(get_mtd_by_name $reservedprefix$filesystemname)
	$update_kernel_binary -o /dev/$mtdprefix$target >/dev/null 2>&1
	tmp=$(get_temp_dir)
	mount -t yaffs2 /dev/$mtdblockname$target "$tmp"
	cp -a /wrapper/* "$tmp"
	rc=$?
	umount "$tmp"
	remove_directory "$tmp"
	return $rc
}
#
# copy running system to alternative partitions
#
copy_running_system()
{
	local rc
	# prepare MTD writes
	# notify power management
	echo MODE=update > /dev/avm_power
	# prevent unwanted watchdog restarts, may be necessary but update is very fast
	# echo "disable" > /dev/watchdog
	copy_kernel_image
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=44
	else
		copy_filesystem
		rc=$?
		if [ $rc -ne 0 ]; then
			rc=45
		fi
	fi
	return $rc
}
#
# copy new root file system to alternative wrapper partition
# $1 - file name of new root file system image
#
copy_new_root_filesystem()
{
	local src="$1" target tmp
	target=$(get_mtd_by_name $reservedprefix$filesystemname)
	tmp="$(get_temp_dir)"
	mount -t yaffs2 /dev/$mtdblockname$target "$tmp"
	cp -a "$src" "$tmp/$rootfsname"
	rc=$?
	umount "$tmp"
	remove_directory "$tmp"
	return $rc
}
#
# get squash file system block size
# $1 - source file system name
#
get_squashfs_blocksize() 
{
	sq3_unsquashfs -s "$1" 2>/dev/null | sed -n -e "s/^Block size \(.*\)/\1/p"
}
#
# get squash file system block size
# $1 - source file system name
#
get_squashfs_endianess()
{ 
	local endianess=0 endian
	endian=$(sq3_unsquashfs -s "$1" 2>/dev/null | sed -n -e "s/Found a valid \((big|litte)\) endian SQUASHFS/\1/p")
	[ ${#endian} -gt 0 ] && [ x"$endian" == xlittle ] && endianess=1
	echo $endianess
	return 0
}
#
# unpack squash file system
# $1 - source file system name
# $2 - target directory (has to exist)
# $3 - optional file with list of names to unpack
#
unpack_squashfs()
{
	local src="$1" target="$2" files="$3" popd rc
	if [ -r "$src" ]; then
		[ -z $files ] || files="-e $files"
		popd="$(pwd)"
		cd "$target"
		sq3_unsquashfs -info "$src" $files 
		rc=$?
		cd "$popd"
	else
		rc=38
	fi
	return $rc
}
#
# pack squash file system image from source tree
# $1 - source directory
# $2 - target file name
# $3 - endianess (0 - BE, 1 - LE)
# $4 - block size
#
pack_squashfs()
{
	local src="$1" target="$2" endian blocksize="$4" popd rc
	[ $3 -eq 0 ] && endian="-be" || endian="-le"
	popd="$(pwd)"
	cd "$src"
	sq3_mksquashfs squashfs-root "$target" -info -b $blocksize $endian
	rc=$?
	cd "$popd"
	return $rc
}
#
# check, if an option is supported
# $1 - option to look for
# $2 - options from script
is_supported()
{
	local option="$1" options="$2" opt rc=0
	for opt in $options; do
		curr="$opt"
		if [ $(expr index "\(" "$opt") -gt 0 ]; then
			opt="${opt%%(*)}"
		fi
		if [ x"$opt" == x"$option" ]; then
			echo "$curr"
			rc=1
			break
		fi
	done
	return $rc
}
#
# execute a modscript without further user interaction
# $1 - script name
# $2 - root file system directory
# $3 - mode (auto / onrequest)
#
execute_modscript()
{
	local script="$1" scriptname="${script##*/}" rootdir="$2" mode="$3" rc=0 supports name language uselang languages header opt msg
	header="$(sed -n -e "1p" "$script")"
	if [ x"$header" == x"# MODFS_MODSCRIPT" ]; then
		supports="$(sed -n -e "s/^# SUPPORTS \(.*\)/\1/p" "$script")"
		name="$(sed -n -e "s/^# NAME \(.*\)/\1/p" "$script")"
		name="${name// /\\ }"
		if [ ${#name} -gt 0 -a ${#supports} -gt 0 ]; then
			if [ x"$mode" == xauto ]; then
				echo -e "$(get_localized $lang 172 "$name")" 1>&2
				progress 1 173	
			fi
			language="$(is_supported 'language' "$supports")"
			if [ $? -eq 1 ]; then
				languages="${language##language(}"
				languages="${languages%)}"
				uselang=$(IFS=, set -- $languages; for lng in $@; do [ $lng == $lang ] && echo $lng && break; done)
				if [ ${#uselang} -eq 0 ]; then
					[ x"$mode" == xauto ] && progress 3 174
					uselang=en
				else
					[ x"$mode" == xauto ] && progress 3 96
				fi
			else
				[ x"$mode" == xauto ] && progress 3 174
				uselang=en
			fi
			progress 1 175
			opt=$(is_supported 'precheck' "$supports")
			if [ $?	-eq 1 ]; then
				# execute pre check
				msg="$($shl $script $uselang $rootdir $mode precheck 2>&1)"
				rc=$?
				if [ $rc -gt 0 ]; then
					progress 3 177 $rc
					echo "$msg" 1>&2
				else
					progress 3 96
					[ ${#msg} -gt 0 ] && echo -e "$msg" 1>&2
				fi
			else
				progress 3 176
			fi
			if [ $rc -eq 0 ]; then
				progress 1 178
				msg="$($shl $script $uselang $rootdir $mode install 2>&1)"
				rc=$?
				if [ $rc -gt 0 ]; then
					progress 3 177 $rc
					echo "$msg" 1>&2
				else
					progress 3 96
					[ ${#msg} -gt 0 ] && echo -e "$msg" 1>&2
					progress 1 179
					opt=$(is_supported 'postcheck' "$supports")
					if [ $?	-eq 1 ]; then
						# execute post check
						msg="$($shl $script $uselang $rootdir $mode postcheck 2>&1)"
						rc=$?
						if [ $rc -gt 0 ]; then
							progress 3 177 $rc
							echo "$msg" 1>&2
						else
							progress 3 96
							[ ${#msg} -gt 0 ] && echo -e "$msg" 1>&2
						fi
					else
						progress 3 176
					fi
				fi
			fi
		else
			echo -e "$(get_localized $lang 60 "$scriptname")" 1>&2
			rc=60
		fi
	else
		echo -e "$(get_localized $lang 61 "${scriptname}")" 1>&2
		rc=61
	fi
	echo -e "$(get_localized $lang 180 "${name:-$scriptname}" $rc)" 1>&2
	return $rc
}
#
# read description with the specified language from script file
# $1 - language
# $2 - script file
#
get_description()
{
	local language="$1" script="$2" rc=0 append=0 tempdir tempfile line
	tempdir="$(get_temp_dir)"
	tempfile="$tempdir/$(date +%s)"
	sed -n -e "/^# MODFS_MODSCRIPT\$/,/^# EOH\$/p" $script | sed -e "1d;\$d;/^# SUPPORTS.*\$/d;/^# NAME.*\$/d" >"$tempfile"
	while read line; do
		if [ x"${line:0:13}" == x"# DESCRIPTION" ]; then
			if [ $language == - ]; then
				if [ x"$line" == x"# DESCRIPTION" ]; then
					append=1
				else
					append=0
				fi
			else
				if [ x"$line" == x"# DESCRIPTION $language" ]; then
					append=1
				else
					append=0
				fi
			fi
		else
			if [ $append -eq 1 ]; then
				description="$description${description:+\n}${line:2}"
			fi
		fi
	done <"$tempfile"
	rm "$tempfile"
	remove_directory "$tempdir"
	echo "$description"
	return $rc
}
#
# ask the user to execute a modscript
# $1 - script name
# $2 - root file system directory
#
execute_optional_modscript()
{
	local script="$1" scriptname="${script##*/}" rootdir="$2" rc=0 supports name language uselang languages header desc msg doit
	header="$(sed -n -e "1p" "$script")"
	if [ x"$header" == x"# MODFS_MODSCRIPT" ]; then
		supports="$(sed -n -e "1,/^# EOH\$/s/^# SUPPORTS \(.*\)/\1/p" "$script")"
		name="$(sed -n -e "1,/^# EOH\$/s/^# NAME \(.*\)/\1/p" "$script")"
		name="${name// /\\ }"
		if [ ${#name} -gt 0 -a ${#supports} -gt 0 ]; then
			echo -e "$(get_localized $lang 172 "$name")" 1>&2
			progress 1 173	
			language="$(is_supported 'language' "$supports")"
			if [ $? -eq 1 ]; then
				languages="${language##language(}"
				languages="${languages%)}"
				uselang=$(IFS=, set -- $languages; for lng in $@; do [ $lng == $lang ] && echo $lng && break; done)
				if [ ${#uselang} -eq 0 ]; then
					progress 3 174
					uselang=en
				else
					progress 3 96
				fi
			else
				progress 3 174
				uselang=en
			fi
			sleep 1
			desc="$(sed -n -e "/^# DESCRIPTION $uselang\$/=" "$script")"
			if [ ${#desc} -eq 0 ]; then
				desc="$(sed -n -e "/^# DESCRIPTION\$/=" "$script")"
				if [ ${#desc} -eq 0 ]; then
					desc="$(get_localized $lang 181)"
				else
					desc="$(get_description - "$script")"
				fi
			else
				desc="$(get_description $uselang "$script")"
			fi
			msg="$(get_localized $lang 182 "$name" "%description%")"
			msg="${msg//%description%/$desc}"
			doit=$(ask_yes_or_no n "$msg")
			if [ x$doit == xY ]; then
				execute_modscript "$script" "$rootdir" onrequest
			fi 
		else
			echo -e "$(get_localized $lang 60 "${scriptname}")" 1>&2
			rc=60
		fi
	else
		echo -e "$(get_localized $lang 61 "${scriptname}")" 1>&2
		rc=61
	fi
	return $rc
}
#
# execute modification scripts
# - only execute scripts, which are "world-executable", while in batch mode
# - execute the other scripts in a 2nd step, asking the user to confirm each one
# $1 - source tree
# $2 - scripts directory
#
modify_rootfs()
{
	local target="$1" scripts="$2" rc=0 line lines lrc filelist script donelist tmpdir flags execute
	tmpdir="$(get_temp_dir)"
	# short stop to ensure an unique temporary directory name (contains the unix time)
	sleep 1
	filelist="$tmpdir/scripts"
	donelist="$tmpdir/executed"
	find "$scripts" -follow -xdev -type f | sort >"$filelist"
	lines=$(sed -n -e "\$=" "$filelist")
	line=0
	while [ $line -lt $lines ]; do
		let line+=1
		script="$(sed -n -e "${line}p" "$filelist")"
		flags=$(stat -c %a $script)
		execute=$(( ( ${flags:2:1} & 1 ) + ( ${flags:1:1} & 1 ) + ( ${flags:0:1} & 1 ) ))
		[ $execute -lt 3 ] && continue
		echo "\|^$script\$|d" >>$donelist
		execute_modscript "$script" "$target" auto
		lrc=$?
		[ $lrc -gt $rc ] && rc=$lrc
	done
	sed -f "$donelist" -i "$filelist"
	lines=$(sed -n -e "\$=" "$filelist")
	line=0
	while [ $line -lt $lines ]; do
		let line+=1
		script="$(sed -n -e "${line}p" "$filelist")"
		flags=$(stat -c %a $script)
		execute=$(( ( ${flags:1:1} & 1 ) + ( ${flags:0:1} & 1 ) ))
		[ $execute -lt 2 ] && continue
		execute_optional_modscript "$script" "$target"
		lrc=$?
		[ $lrc -gt $rc ] && rc=$lrc
	done
	remove_directory "$tmpdir"
	return $rc
}
#
# extract squash file system from firmware image
# $1 - source firmware image
# $2 - target file name and path (path has to be a valid directory)
#
extract_rootfs()
{
	local src="$1" target="$2" tmp rc mp tmpdir
	tmpdir="$(get_temp_dir)"
	tmp="$tmpdir/wrapperfs"
	tar -xOf "$src" "$firmware_filesystem_image" >"$tmp" 2>/dev/null
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=39
	else
		sleep 1 # "hack" to ensure unique tempdir name
		mp="$(get_temp_dir)"
		mount "$tmp" "$mp"
		rc=$?
		if [ $rc -ne 0 ]; then
			rc=40
		else
			cp -a "$mp/$rootfsname" "$target"
			rc=$?
			if [ $rc -ne 0 ]; then
				rc=41
			fi
			umount "$mp"
		fi
		remove_directory "$mp"
	fi
	rm $tmp 2>/dev/null
	remove_directory "$tmpdir"
	return $rc
}
#
# get system version
# $1 - system root
#
get_system_version() { $shl "$1$versionfilename" --version; }
#
# download firmware file from manufacturer
# $1 - target file name
#
download_firmware()
{
	local ftppath target="$1" hwrev rc=0 version
	hwrev="$(get_hardware_revision)"
	version=$(get_system_version)
	eval ftppath="$(echo \$ftp_path_$hwrev)"
	eval ftppath="$(echo $ftppath)"
	ftpget $ftp_server "$target" "$ftppath" 2>/dev/null
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=42
	else
		if [ $(stat -c %s "$target") -eq 0 ]; then
			rc=43
		fi
	fi
	return $rc
}
#
# check space value for human readable format
# - the ash shell at the box is limited to 32-bit arithmetics, GB units are impossible
# $1 - space value (n, nK or nM)
#
get_numeric_space_value()
{
	local rc=0 number=$1 size=0 len last
	if [ ${#number} -eq 0 ]; then
		rc=127
	else
		last=${number:$(( ${#number} - 1 )):1}
		len=$(( ${#number} - 1 ))
		num=${number:0:$len}
		if [ $last == K ]; then
			size=$(( $num * 1024 ))
		else
			if [ $last == M ]; then
				size=$(( $num * 1024 * 1024 ))
			else
				size=$number
			fi
		fi
	fi
	echo $size
	return $rc
}
#
# check free tmpfs space
# $1 - free space needed for rc=0
# $2 - free space needed for rc=1
#
check_free_tmpfs()
{
	local rc=0 size bs free freespace rc1 rc2
	wanted=$(get_numeric_space_value $1)
	rc1=$?
	needed=$(get_numeric_space_value $2)
	rc2=$?
	if [ $rc1 -eq 0 -a $rc2 -eq 0 ]; then
		bs=$(stat -c %S -f $tmpfsbasedir)
		free=$(stat -c %f -f $tmpfsbasedir)
		freespace=$(( bs * free ))
		if [ $freespace -lt $wanted ]; then
			if [ $freespace -lt $needed ]; then
				rc=2
			else
				rc=1
			fi
		else
			rc=0
		fi
	else
		let rc=rc1+rc2
	fi
	return $rc
}
#
# check, if the specified path is on volatile storage
#
is_tmpfs()
{
	local path="$1" 
	type=$(stat -c %T -f "$path")
	if [ x$type == x"tmpfs" ]; then
		echo 1
	else
		echo 0
	fi
}
#
# get nand file system mount point
#
get_nand_mountpoint()
{
	local rc=0 nandmajor nandminor device mountpoint type options x y 
	if [ $CONFIG_NAND == y ]; then
		nandminor=$(get_mtd_by_name $nandname)
		if [ ${#nandminor} -gt 0 ]; then
			nandmajor=$(sed -n -e "s/^ *\([0-9]*\) $mtdblockname/\1/p" /proc/devices)
			rc=1
			while read device mountpoint type options x y; do
				if [ x"$(stat -c %F $device 2>/dev/null)" == x"block special file" ]; then
					if [ $(( 0x$(stat -c %t $device 2>/dev/null) )) -eq $nandmajor ]; then
						if [ $(( 0x$(stat -c %T $device 2>/dev/null) )) -eq $nandminor ]; then
							echo $mountpoint
							rc=0
							break
						fi
					fi
				fi
			done </proc/mounts
		else
			rc=2
		fi
	else
		rc=2
	fi
	return $rc
}
#
# check free nand space
# $1 - free space needed
#
check_free_nand()
{
	local rc=0 size bs free freespace
	size=$(get_numeric_space_value $1)
	rc=$?
	if [ $rc -eq 0 ]; then
		nand=$(get_nand_mountpoint)
		bs=$(stat -c %S -f $nand)
		free=$(stat -c %f -f $nand)
		freespace=$(( bs * free ))
		if [ $freespace -lt $size ]; then
			rc=1
		else
			echo "$nand:$freespace"
			rc=0
		fi
	fi
	return $rc
}
#
# find USB device mount point(s)
# - print all network (block devices) or USB mount points
#
get_possible_usb_mountpoints()
{
	local device mountpoint type options x y major dev i count=0
	while read device mountpoint type options x y; do
		if [ x"$(stat -c %F $device 2>/dev/null)" == x"block special file" ]; then
			major=$(( 0x$(stat -c %t $device 2>/dev/null) ))
			dev=$(sed -e "1,/^Block devices:/d" /proc/devices | sed -n -e "s/^ *$major \(.*\)/\1/p")
			i=$(index_of_item "$dev" "loop $mtdblockname")
			if [ $? -eq 1 ]; then
				# not on loop or mtdblock - USB or network
				echo $mountpoint
				let count+=1
			fi
		fi
	done </proc/mounts
	return $count
}
#
# check space on mount points at stdin
# - stdin has to contain one line for each mount point of a file system to check
# - stdout will contain a list of all mount points with enough room and the free space available there
# $1 - free space needed
#
check_space()
{
	local needed outpath mp bs free_blocks blocks_in_K free_size unit needed_blocks
	needed=$(get_numeric_space_value $1)
	while read mp; do
		bs=$(stat -c %S -f $mp)
		free_blocks=$(stat -c %f -f $mp)
		# 32-bit arithmetics on box are a little bit annoying
		if [ $(( bs * free_blocks )) -lt 0 ]; then
			if [ $bs -gt 1024 ]; then
				blocks_in_K=$(( $bs / 1024 ))
				if [ $(( blocks_in_K * free_blocks )) -lt 0 ]; then
					# very much free space, let's try it with MBytes
					free_size=$(( free_blocks * ( bs / 1024 ) ))
					unit=K
					needed_blocks=$(( needed / bs ))
				else
					free_size=$(( blocks_in_K * free_blocks ))
					unit=K
					needed_blocks=$(( needed / bs ))
				fi
			else # block size is lower than 1K, awesome ... free_blocks seems to be very large
				free_size=$(( free_blocks / ( 1024 / bs ) ))
				unit=K
				needed_blocks=$(( needed / bs ))
			fi
		else
			free_size=$(( bs * free_blocks ))
			unit=""
			needed_blocks=$(( needed / bs ))
		fi
		if [ $free_blocks -ge $needed_blocks ]; then
			let mpcount+=1
			outpath="$outpath $mp:$free_size$unit"
		fi
	done
	echo "$outpath"
}
#
# find any place with enough free storage to host our ext3 image
# $1 - free space needed
# $2 - nonand -> ignore NAND storage, withnand -> NAND storage *and* other places, acceptnand -> NAND storage is able to satisfy the requirements
#
find_free_storage_space()
{
	local rc=0 needed mp mpcount=0 out bs free_blocks free_size needed_blocks unit
	needed=$(get_numeric_space_value $1)
	rc=$?
	if [ $rc -eq 0 ]; then
		if [ x$2 == xnonand ]; then
			rc=1
		else
			out=$(check_free_nand $1)
			rc=$?
			if [ $rc -eq 0 ]; then
				if [ x$2 == xacceptnand ]; then
					rc=0
				else
					if [ x$2 == xwithnand ]; then
						rc=1
					fi
				fi
			fi
		fi
		if [ $rc -ne 0 ]; then
			out="$out $(get_possible_usb_mountpoints | check_space $needed)"
			if [ ${#out} -gt 0 ]; then
				echo "$out"
				rc=0
			else
				rc=1
			fi
		else
			echo "$out"
		fi
	fi
	return $rc
}
#
# get a readable output for free space
# $1 - space to convert to a human readable format (at least KByte, better MByte)
#
get_display_space()
{
	local input="$1" len last num output=0
	len=$(( ${#input} - 1 ))
	last=${input:$len:1} num=${input:0:$len}
	if [ $last == K ]; then
		output=$(( num / 1024 ))
	else
		if [ $last == M ]; then
			output=$num
		else
			num=$(( $num$last ))
			output=$(( num / 1024 / 1024 ))
		fi
	fi
	if [ $output -gt 10240 ]; then
		echo "$(( output / 1024 )) GB"
	else
		echo "$output MB"
	fi
	return
}
#
# ask the user to select one of the available working directories
# $1 - available mount points
#
get_path_selection()
{
	local mps="$1" msglist="$2" msg1 msg2 msg3 msg4 msg5 msg6 msg7 rc=0 letter letters="abcdefghijklmnopqrstuvwxyz" index
	set -- $msglist
	msg1=$1
	msg2=$2
	msg3=$3
	msg4=$4
	msg5=$5
	msg6=$6
	msg7=$7
	echo "$(get_localized $lang $msg1)" 1>&2
	while [ 1 -eq 1 ]; do
		echo -e "\n$(get_localized $lang $msg2)\n" 1>&2
		index=0
		answers=""
		for mp in $mps; do
			space="${mp##*:}"
			path="${mp%%:*}"
			letter=${letters:$index:1}
			freespace=$(get_display_space $space)
			device=$(sed -n -e "s|^\([^ ]*\) $path .*|\1|p" /proc/mounts)
			filesystem=$(sed -n -e "s|^[^ ]* $path \([^ ]*\) .*|\1|p" /proc/mounts)
			let index+=1
			line="$(get_localized $lang $msg3 "$letter" "$device" "$filesystem" "$path" "$freespace")"
			echo -e "$line" 1>&2
			answers=$answers$letter
		done
		echo -e "$(get_localized $lang $msg5)" 1>&2
		echo -ne "\n$(get_localized $lang $msg4) " 1>&2
		while read -n 10 -s -t 1; do :; done
		read -n 1 -s selection
		case $selection in
			[qQ])
				echo -e "$selection$(get_localized $lang $msg7)" 1>&2
				return 1
				;;
			*)
				if [ ${#selection} -gt 0 ]; then
					if [ $(expr index $selection $answers$(uppercase $answers)) -gt 0 ]; then
						break
					fi 
				fi
				echo -e "$selection\n$(get_localized $lang $msg6)" 1>&2
				continue
				;;
		esac
		break
	done
	echo -ne "$selection\n\n$msgtext_normal" 1>&2
	index=0
	for mp in $mps; do
		letter=${letters:$index:1}
		if [ $letter == $selection -o $(uppercase $letter) == $selection ]; then
			echo $mp
			return 0
		fi
		let index+=1
	done
	return 1
}
#
# find a convenient storage place to fulfill the specified space requirements
# - the allowed places to search are 'tmpfs', 'nand', 'storage' in any order (2nd argument)
# $1 - space needed
# $2 - order of space to search
#
find_free_space()
{
	local wanted=$1 order="$2" rc=1 path
	for place in $order; do
		case $place in
			tmpfs)
				check_free_tmpfs $wanted $wanted
				rc=$?
				if [ $rc -eq 0 ]; then
					echo $tmpfsbasedir
					break
				fi
				;;
			nand)
				path=$(check_free_nand $wanted)
				rc=$?
				if [ $rc -eq 0 ]; then
					echo ${path%%:*}
					break
				fi
				;;
			storage)
				path="$(find_free_storage_space $wanted nonand)"
				rc=$?
				if [ $rc -eq 0 ]; then
					count=0
					for mp in $path; do
						let count+=1
					done
					if [ $count -gt 1 ]; then
						path=$(get_path_selection "$path" "122 123 124 125 126 127 131")
						rc=$?
						if [ $rc -eq 0 ]; then	
							echo ${path%%:*}
							break
						fi						
					else
						echo ${path%%:*}
						break
					fi
				fi
				;;
			*)
				;;
		esac
	done
	return $rc
}
#
# find mount point for the specified path
# $1 - path below the needed mount point
#
get_mountpoint()
{
	local path="$1" rc=0
	while [ ${#path} -gt 0 ]; do
		dev="$(sed -n -e "s|^\([^ \t]*\) $path \(.*\) \(.*\) \(.\) \(.\)|\1|p" /proc/mounts)"
		if [ ${#dev} -gt 0 ]; then
			break
		else
			path="${path%/*}"
		fi
	done
	echo $path
	return $rc
}
#
# let the user select a non-volatile storage place with enough free space
#
get_persistent_path()
{
	local wanted rc=0 count
	wanted=$(get_numeric_space_value $1)
	path="$(find_free_storage_space $wanted withnand)"
	rc=$?
	if [ $rc -eq 0 ]; then
		count=0
		for mp in $path; do
			let count+=1
		done
		if [ $count -gt 1 ]; then
			path=$(get_path_selection "$path" "136 137 124 138 126 127 139")
			rc=$?
			if [ $rc -eq 0 ]; then	
				echo ${path%%:*}
			fi						
		else
			echo ${path%%:*}
		fi
	fi
	return $rc
}
#
# check a possible squashfs image file
# $1 - image file name
#
check_squashfs_image()
{
	local squashfsimage="$1" rc=0
	progress 1 165 "$squashfsimage"
	sq3_unsquashfs -stat "$squashfsimage" 2>/dev/null 1>&2
	rc=$?
	if [ $rc -ne 0 ]; then
		progress 3 166
		# nope
		echo -e "$(get_localized $lang 162 "$squashfsimage")" 1>&2
		rc=1
	else
		progress 3 96
		rc=0
	fi
	return $rc
}
#
# check a possible firmware image file
# $1 - image file name
#
check_firmware_image()
{
	local firmwareimage="$1" rc=0
	progress 1 167 "$firmwareimage"
	tar -tf "$firmwareimage" "$firmware_filesystem_image" 2>/dev/null 1>&2
	rc=$?
	if [ $rc -ne 0 ]; then
		progress 3 166
		# nope
		echo -e "$(get_localized $lang 163 "$firmwareimage")" 1>&2
		rc=1
	else
		progress 3 96
		# ok, let's get the filesystem image from it
		working_directory="$(get_working_directory $extract_space_needed "tmpfs nand storage")"
		rc=$?
		if [ $rc -ne 0 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
			return $rc
		fi
		image_directory="$working_directory/$(date +%s)"
		mkdir -p "$image_directory"
		echo "rm -r $image_directory" >>$tempfilelist
		progress 1 132
		extract_rootfs "$firmwareimage" "$image_directory/$rootfsname"
		rc=$?
		if [ $rc -ne 0 ]; then
			progress 3 97	
			echo -e "$(get_localized $lang 163 "$firmwareimage")" 1>&2
			rc=1
		else
			# we've got a squashfs image file
			progress 3 96
			squashfsimage="$image_directory/$rootfsname"
			echo "$squashfsimage"
			rc=0
		fi
	fi
	return $rc
}
#
# check the embedded version script of a squashfs image
# $1 - image file name
#
check_squashfs_file_version()
{
	local squashfsimage="$1" rc=0 working_directory checkdir imageversion
	# check squashfs version
	working_directory="$(get_working_directory 1M "tmpfs nand storage")"
	rc=$?
	if [ $rc -ne 0 ]; then
		echo -e "$(get_localized $lang $rc)" 1>&2
		exit $rc
	fi
	progress 1 168 $squashfsimage
	checkdir="$(get_temp_dir)"
	sq3_unsquashfs -dest "$checkdir/test" "$squashfsimage" "$versionfilename" 2>/dev/null 1>&2
	if [ -f "$checkdir/test$versionfilename" ]; then
		# check image version
		imageversion="$($checkdir/test$versionfilename -v)"
		if [ x$imageversion == x$(get_system_version) ]; then
			progress 3 96
			rc=0
		else
			progress 3 97
			echo -e "$(get_localized $lang 164 "$squashfsimage")" 1>&2
			rc=1
		fi
	else
		# no version file at image, usually not an original
		progress 3 97
		echo -e "$(get_localized $lang 162 "$squashfsimage")" 1>&2
		rc=1
	fi
	remove_directory "$checkdir"
	return $rc
}
#
# find an appropriate image file at the specified device
# $1 - mount point
#
find_image_file()
{
	local mp="$1" squashfsimage firmwareimage rc=0 image_directory working_directory 
	if [ -f "$mp/$rootfsname" ]; then
		# possibly a squashfs as pattern
		squashfsimage="$mp/$rootfsname"
		check_squashfs_image "$squashfsimage"
		rc=$?
	else
		if [ -f "$mp/$firmwarestoragename" ]; then
			# possibly a firmware image as pattern
			firmwareimage="$mp/$firmwarestoragename"
			squashfsimage="$(check_firmware_image "$firmwareimage")"
			rc=$?
		else
			rc=1
		fi
	fi
	if [ $rc -eq 0 ]; then
		check_squashfs_file_version "$squashfsimage"
		rc=$?
		[ $rc -eq 0 ] && echo "$squashfsimage"
	fi
	return $rc
}
#
# let the user select a non-volatile storage place with an existing squashfs image
#
get_input_image_path()
{
	local rc=0 count notfound=0 path mp squashfsimage firmwareimage working_directory image_directory checkdir imageversion space letter answers filesystem device letters="abcdefghijklmno" pathinput=0 breaknow=0 pathto
	path="$(find_free_storage_space 1K withnand)"
	rc=$?
	if [ $rc -eq 0 ]; then
		count=0
		for mp in $path; do
			let count+=1
		done
		if [ $count -eq 1 ]; then
			# only one suitable place found, try to find an image there
			mp="${path%%:*}"
			squashfsimage="$(find_image_file "$mp")"
			rc=$?
			if [ $rc -eq 1 ]; then
				notfound=1
				rc=0
			fi
			echo -ne "\n" 1>&2
		else
			notfound=1
		fi
		if [ $notfound -eq 1 ]; then
			# no file found yet, let the user specify a new one or abort the execution
			echo "$(get_localized $lang 156 $firmwarestoragename $rootfsname)" 1>&2
			while [ 1 -eq 1 ]; do
				if [ $count -gt 1 ]; then
					# more than one possible place to store the pattern
					pathinput=0
					selection=""
					while [ 1 -eq 1 ]; do
						echo -e "\n$(get_localized $lang 157)\n" 1>&2
						index=0
						answers=""
						for mp in $path; do
							space="${mp##*:}"
							pathto="${mp%%:*}"
							letter=${letters:$index:1}
							device=$(sed -n -e "s|^\([^ ]*\) $pathto .*|\1|p" /proc/mounts)
							filesystem=$(sed -n -e "s|^[^ ]* $pathto \([^ ]*\) .*|\1|p" /proc/mounts)
							let index+=1
							line="$(get_localized $lang 158 "$letter" "$device" "$filesystem" "$pathto")"
							echo -e "$line" 1>&2
							answers=$answers$letter
						done
						echo -e "$(get_localized $lang 159)" 1>&2
						echo -e "$(get_localized $lang 160)" 1>&2
						echo -ne "\n$(get_localized $lang 161) " 1>&2
						while read -n 10 -s -t 1; do :; done
						read -n 1 -s selection
						case $selection in
							[qQ])
								echo -e "$selection$(get_localized $lang 131)" 1>&2
								return 1
								;;
							[pP])
								pathinput=1
								breaknow=1
								rc=1
								;;
							*)
								if [ ${#selection} -gt 0 ]; then
									if [ $(expr index $selection $answers$(uppercase $answers)) -gt 0 ]; then
										breaknow=1
									fi 
								else
									echo -e "$selection\n$(get_localized $lang 127)" 1>&2
									continue
								fi
								;;
						esac
						if [ x$selection == xp ]; then
							echo -ne "$selection\n$msgtext_normal" 1>&2
						else
							echo -ne "$selection\n\n$msgtext_normal" 1>&2
						fi
						[ $breaknow -eq 1 ] && break
					done
				else
					selection=a
					pathinput=0
				fi
				let count-=1
				if [ $pathinput -ne 1 ]; then
					# input was not 'p'
					index=0
					newpath=""
					for mp in $path; do
						letter=${letters:$index:1}
						if [ $letter == $selection -o $(uppercase $letter) == $selection ]; then
							# use that drive to find our file
							checked="${mp%%:*}"
							squashfsimage="$(find_image_file "$checked")"
							rc=$?
							if [ $rc -eq 0 ]; then
								# ok, we've found an image
								echo "$squashfsimage"
								count=0
							fi
						else
							# the probed path will be removed from the list
							newpath=""$newpath" "$mp""
						fi	
						let index+=1
					done
					if [ $rc -ne 0 ]; then
						# show error message and try again without the probed path
						echo -e "$(get_localized $lang 169 "$checked")" 1>&2
						path="$newpath"
						rc=1
					fi
				fi
				# we're finished, if we've found an image or the choice was 'p' or there're no more places to search
				[ $count -eq 0 -o $pathinput -eq 1 ] && echo "" 1>&2 && break
			done
			if [ $rc -eq 1 ]; then
				while [ 1 -eq 1 ]; do
					# let the user select his own source
					echo "$(get_localized $lang 170)" 1>&2
					read pathname
					if [ x"$pathname" == xq ]; then
						echo -e "$(get_localized $lang 116)" 1>&2
						rc=1
						break
					fi
					echo -ne "$msgtext_normal" 1>&2
					if [ -f "$pathname" ]; then
						check_squashfs_image "$pathname"
						rc=$?
						if [ $rc -gt 1 ]; then
							return $rc
						else
							squashfsimage="$pathname"
						fi
						if [ $rc -eq 1 ]; then
							squashfsimage="$(check_firmware_image "$pathname")"
							rc=$?
						fi
						if [ $rc -eq 0 ]; then
							check_squashfs_file_version "$squashfsimage"
							rc=$?
							if [ $rc -eq 0 ]; then
								echo "$squashfsimage"
								break
							fi
						fi
					else
						echo "$(get_localized $lang 171 "$pathname")" 1>&2
					fi
				done
			fi
		else
			# pattern image found
			echo "$squashfsimage"
		fi
	else
		echo -e "$(get_localized $lang 58)" 1>&2
		rc=58
	fi
	return $rc
}
#
# check prerequisites
# - check hardware revision
# - find 'switch' variable at environment
# - find kernel partitions
# - compare kernel hashes
# - find filesystem partitions
#
check_prerequisites()
{
	local rc=0 nxt k1 k2 hwrev f1 f2 path
	echo -ne "$msgtext_clearscreen" 1>&2
	# get hardware revision
	progress 1 98
	hwrev="$(get_hardware_revision)"
	if [ ${#hwrev} -gt 0 ]; then
		progress 3 96
		# check hardware revision
		progress 1 99
		if check_hardware_revision "$hwrev"; then
			progress 3 97
			msg="$(get_localized $lang 36 $hwrev)"
			echo -e "$msg\n" 1>&2
			rc=36
		else
			progress 3 96
			# find boot time system selection switch
			progress 1 100
			nxt=$(get_system_switch)
			if [ ${#nxt} -eq 0 ]; then
				progress 3 97
				msg="$(get_localized $lang 35 $fsvarname)"
				echo -e "$msg\n" 1>&2
				rc=35
			else
				progress 3 96
				# check, if system is modified already 
				progress 1 101
				if is_switched; then
					if [ $undo_switch -eq 1 ]; then
						progress 3 96
						return 0
					else
						progress 3 97
						msg="$(get_localized $lang 37)"
						echo -e "$msg\n" 1>&2
						rc=37
					fi
				else
					if [ $undo_switch -eq 1 ]; then
						progress 3 97
						return 1
					fi
					progress 3 96
					# find kernel MTD
					progress 1 102
					k1=$(get_mtd_by_name $kernelname)
					if [ ${#k1} -eq 0 ]; then
						progress 3 97
						msg="$(get_localized $lang 33 $kernelname)"
						echo -e "$msg\n" 1>&2
						rc=33
					else
						progress 3 96
						# find alternative kernel MTD
						progress 1 103
						k2=$(get_mtd_by_name $reservedprefix$kernelname)
						if [ ${#k2} -eq 0 ]; then
							progress 3 97
							msg="$(get_localized $lang 34 $reservedprefix$kernelname)"
							echo -e "$msg\n" 1>&2
							rc=34
						else
							progress 3 96
							# compare kernel versions
							progress 1 104
							msg="$(check_kernels $k1 $k2)"
							rc=$?
							if [ $rc -eq 0 ]; then
								progress 3 96
								# find filesystem MTD
								progress 1 105
								f1=$(get_mtd_by_name $filesystemname)
								if [ ${#f1} -eq 0 ]; then
									progress 3 97
									msg="$(get_localized $lang 48 $filesystemname)"
									echo -e "$msg\n" 1>&2
									rc=48
								else
									progress 3 96
									# find alternative filesystem MTD
									progress 1 106
									f2=$(get_mtd_by_name $reservedprefix$filesystemname)
									if [ ${#f2} -eq 0 ]; then
										progress 3 97
										msg="$(get_localized $lang 49 $reservedprefix$filesystemname)"
										echo -e "$msg\n" 1>&2
										rc=49
									else
										progress 3 96
										# check free space at tmpfs 
										progress 1 117
										check_free_tmpfs $free_space_at_tmpfs $warning_space_at_tmpfs
										rc=$?
										if [ $rc -gt 1 ]; then
											progress 3 97
											msg="$(get_localized $lang 50)"
											echo -e "$msg\n" 1>&2
											rc=50
										else
											if [ $rc -eq 1 ]; then
												progress 3 118
											else
												progress 3 96
											fi
											# find enough free local space to unpack the squashfs image
											progress 1 119
											path=$(find_free_storage_space $free_space_for_unpack 2>/dev/null)
											rc=$?
											if [ $rc -eq 0 ]; then
												progress 3 96
											else
												progress 3 97
												msg="$(get_localized $lang 51 $free_space_for_unpack)"
												echo -e "$msg\n" 1>&2
												rc=51
											fi
										fi
									fi
								fi
							else
								progress 3 97
								msg="$(get_localized $lang 32 $filesystemname)"
								echo -e "$msg\n" 1>&2
							fi
						fi
					fi
				fi
			fi
		fi
	else
		progress 3 97
		msg="$(get_localized $lang 47 $hwrevname)" 1>&2
		echo -e "$msg\n" 1>&2
		rc=47
	fi
	return $rc
}
#
# get source selection
#
get_source()
{
	local source selection
	while [ 1 -eq 1 ]; do
		echo -e "\n$(get_localized $lang 110)" 1>&2
		echo -e "$(get_localized $lang 111)" 1>&2
		echo -e "$(get_localized $lang 112)" 1>&2
		echo -e "$(get_localized $lang 113)" 1>&2
		echo -ne "\n$(get_localized $lang 114) " 1>&2
		while read -n 10 -s -t 1; do :; done
		read -n 1 -s selection
		case $selection in
			[aA])
				source=running
				;;
			[bB])
				source=download
				;;
			[cC])
				source=file
				;;
			[qQ])
				source=quit
				;;
			*)
				echo -e "$selection\n$(get_localized $lang 115)" 1>&2
				continue
				;;
		esac
		break
	done
	echo -ne "$selection\n$msgtext_normal" 1>&2
	echo $source
}
#
# get working directory decision from user
#
get_working_directory()
{
	local dir needed="$1" places="$2"
	dir="$(find_free_space $needed "$places")"
	if [ $? -ne 0 ]; then
		return 52
	fi
	echo "$dir"
	return 0
}
#
# remove temporary directories before exiting
#
cleanup()
{
	. $tempfilelist 2>/dev/null
	rm $tempfilelist 2>/dev/null
}
#
# show a spinner as progress indicator at stderr
# - each line output to stdout/stderr leads to a new position of the spinner
# $1 - working directory to build the needed FIFO
#
spinner()
{
	run_spinner()
	{
	    local index=0 positions="|/-\\"
	    while read line; do
	        char=${positions:$index:1}
	        echo -ne "\x1B[1D$char" 1>&2
	        let index+=1
	        [ $index -eq ${#positions} ] && index=0
	    done
	}
    local dir="$1" rc spin_from spinpid
    shift
	echo -ne "  " 1>&2
	spin_from="$dir/$(date +%s)"
    mkfifo "$spin_from"
    run_spinner <"$spin_from" &
	spinpid=$!
    "$@" >"$spin_from" 2>/dev/null
    rc=$?
	wait $spinpid
    rm "$spin_from"
	echo -ne "\x1B[2D" 1>&2
    return $rc
}
#
# execution starts here, if called as shell script
#
# prepare script environment
scriptcalledbyname="$0"
scriptfile="$scriptcalledbyname"
while [ -L "$scriptfile" ]; do scriptfile="$(readlink "$scriptfile")"; done
scriptfile="$(realpath $scriptfile)"
scriptpath="${scriptfile%/*}"
scriptname="${scriptfile##*/}"
#
# FRITZ!Box language environment setting
#
lang=$Language
if [ ! -r $(localedir)/$lang ]; then
	lang=en
	echo "The localized messages file for '$lang' was not found, probing fallback to 'en'." 1>&2
fi
if [ ! -r $(localedir)/$lang ]; then
	echo "The localized messages file for '$lang' does not exist." 1>&2
	exit 66
fi
#
# initialize variables (unnecessary, only for the sake of good order and to get numeric instead of character values as needed)
#
working_directory=""
unpack_directory=""
loopback_host=""
baseimage=""
loopback_used=0
squashfs_blocksize=0
squashfs_endianess=0
rc=0
#
# we'll store an unlink command for all temporary directories and files here and remove it, if the target is deleted elsewhere
#
tempfilelist="$tmpfsbasedir/$$_filelist_$(date +%s)"
touch $tempfilelist
trap 'cleanup' EXIT HUP
#
# check for 'undo' request, which is the only argument, what we expect
#
if [ x$1 == xundo ]; then
	undo_switch=1
	check_prerequisites
	rc=$?
	if [ $rc -eq 0 ]; then
		switchback=$(ask_yes_or_no n "$(get_localized $lang 194)")
		if [ $switchback == Y ]; then
			progress 1 152
			switch_system_to current
			progress 3 96
			echo -e "$(get_localized $lang 154)" 1>&2
			exit 0
		else
			echo -e "$(get_localized $lang 153)" 1>&2
			exit 1
		fi
	else
		echo -e "$(get_localized $lang 151)" 1>&2
		exit 1		
	fi
	exit $rc
else
	undo_switch=0
fi
#
# check prerequisites first, any further action depends on them
#
check_prerequisites
prerc=$?
if [ $prerc -eq 32 ]; then
	copypart=$(ask_yes_or_no n "$(get_localized $lang 192)")
	if [ $copypart == Y ]; then
		copy_running_system
		rc=$?
		if [ $rc -ne 0 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
		else
			echo -e "$(get_localized $lang 183)" 1>&2
			reboot
		fi
	fi
fi
[ $prerc -ne 0 ] && exit $prerc
echo -e "$(get_localized $lang 107 "$(get_system_version)")\n" 1>&2
echo -e "$(get_localized $lang 108)" 1>&2
echo -e "$(get_localized $lang 109)" 1>&2
source=$(get_source)
if [ $source == quit ]; then
	echo -e "$(get_localized $lang 116)" 1>&2
	exit 0
else
	echo -ne "\n" 1>&2
fi
case $source in
	running)
		# nothing to do prior to unpacking
		echo -e "$(get_localized $lang 120)\n" 1>&2
		baseimage="$wrapperdir/$rootfsname"
		;;
	download)
		working_directory="$(get_working_directory $download_space_needed "tmpfs nand storage")"
		rc=$?
		if [ $rc -ne 0 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
			exit $rc
		fi
		progress 1 121
		download_directory="$working_directory/$(date +%s)"
		mkdir -p "$download_directory"
		echo "rm -r $download_directory" >>$tempfilelist
		download_firmware "$download_directory/$firmwarestoragename"
		rc=$?
		if [ $rc -ne 0 ]; then
			if [ $rc -eq 42 ]; then
				progress 3 97
				echo "$(get_localized $lang 42)" 1>&2
			else
				if [ $rc -eq 43 ]; then
					progress 3 97
					echo "$(get_localized $lang 43)" 1>&2
				fi
			fi
			exit $rc
		else
			progress 3 96
			working_directory="$(get_working_directory $extract_space_needed "tmpfs nand storage")"
			rc=$?
			if [ $rc -ne 0 ]; then
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			fi
			image_directory="$working_directory/$(date +%s)"
			mkdir -p "$image_directory"
			echo "rm -r $image_directory" >>$tempfilelist
			progress 1 132
			extract_rootfs "$download_directory/$firmwarestoragename" "$image_directory/$rootfsname"
			rc=$?
			if [ $rc -ne 0 ]; then
				progress 3 97
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			else
				progress 3 96
				baseimage="$image_directory/$rootfsname"
				progress 1 133
				remove_directory "$download_directory"
				progress 3 96
				copybase=$(ask_yes_or_no n "$(get_localized $lang 193)")
				if [ $copybase == Y ]; then
					target=""
					if [ $(is_tmpfs $image_directory) -eq 1 ]; then
						targetdir="$(get_persistent_path $(( $(stat -c %s "$baseimage") + 4096 )) )"
						rc=$?
						if [ $rc -eq 0 ]; then
							target=$targetdir/$rootfsname
						fi
					else
						target="$working_directory/$rootfsname"
					fi
					progress 1 134
					[ $rc -eq 0 ] && mv "$image_directory/$rootfsname" "$target"
					rc=$?
					if [ $rc -ne 0 ]; then
						progress 3 97
						if [ ${#target} -gt 0 ]; then
							echo -e "$(get_localized $lang 53)" 1>&2
							exit 53
						fi
					else
						progress 3 96
						echo -e "$(get_localized $lang 135 "$target")" 1>&2
						baseimage="$target"
						remove_directory "$image_directory"
					fi
				fi
			fi
		fi
		;;
	file)
		baseimage="$(get_input_image_path)"
		rc=$?
		if [ $rc -gt 1 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
			exit $rc
		fi
		# no file name selected means abort execution, error message done already
		[ ${#baseimage} -eq 0 ] && rc=1
		;;
esac
if [ $rc -eq 0 ]; then
	# find a mountpoint with enough free storage for unpacking of squashfs
	# check current working directory (if any) first
	if [ ${#working_directory} -gt 0 ]; then
		path="$(echo "$working_directory" | check_space $free_space_for_unpack)"
		if [ ${#path} -gt 0 ]; then
			# current working directory seems to be suitable
			unpack_directory="$working_directory"
		fi
	else
		# no working directory selected yet
		unpack_directory=""
	fi
	if [ ${#unpack_directory} -eq 0 ]; then
		# we need (a new) working directory with enough free space
		unpack_directory="$(get_working_directory $free_space_for_unpack_tmpfs "tmpfs")"
		rc=$?
		if [ $rc -ne 0 ]; then
			# not enough space on tmpfs, try non-volatile storage now
			unpack_directory="$(get_working_directory $free_space_for_unpack "nand storage")"
			rc=$?
			if [ $rc -ne 0 ]; then
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			fi
		fi
	fi
	if [ $rc -eq 0 ]; then
		if [ ${#unpack_directory} -eq 0 ]; then
			echo -e "$(get_localized $lang 58)" 1>&2
			rc=58
		fi
	fi
	if [ $rc -eq 0 ]; then
		# check file system at mount point - we need a native one
		fs="$(sed -n -e "s|^[^ \t]* $unpack_directory \(.*\) .* . .|\1|p" /proc/mounts)"
		if [ ${#fs} -eq 0 ]; then
			fs="$(sed -n -e "s|^[^ \t]* $(get_mountpoint $unpack_directory) \(.*\) .* . .|\1|p" /proc/mounts)"
		fi
		index_of_item $fs "$nativefilesystems" 1>/dev/null
		ind=$?
		if [ $ind -eq 1 ]; then
			# we'll use a loopback device to mount our ext3 image
			progress 1 140
			unpack_directory="$unpack_directory/$(date +%s)"
			mkdir -p "$unpack_directory"
			echo "rm -r $unpack_directory" >>$tempfilelist
			gunzip -c "$(filesdir)/$packedpartition" >"$unpack_directory/loopback"
			rc=$?
			if [ $rc -eq 0 ]; then
				progress 3 96
				progress 1 141
				loopback_host="$unpack_directory/loopback"
				tmp="$(get_temp_dir)"
				mount -o loop $loopback_host $tmp
				if [ $rc -eq 0 ]; then
					progress 3 96
					loopback_used=1
					unpack_directory="$tmp"
				else
					progress 3 97
					echo -e "$(get_localized $lang 55)" 1>&2
					rc=55
				fi
			else
				progress 3 97
				echo -e "$(get_localized $lang 54)" 1>&2
				rc=54
			fi
		else
			loopback_used=0
			unpack_directory="$unpack_directory/$(date +%s)"
			mkdir -p $unpack_directory
			echo "rm -r $unpack_directory" >>$tempfilelist
		fi
	fi
fi
if [ $rc -eq 0 ]; then
	# unpack squashfs root image
	progress 1 144
	spinner "$unpack_directory" unpack_squashfs "$baseimage" "$unpack_directory"
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
		squashfs_blocksize=$(get_squashfs_blocksize $baseimage)
		squashfs_endianess=$(get_squashfs_endianess $baseimage)
		echo -e "$(get_localized $lang 145 "$unpack_directory/$squashfsdirname")" 1>&2
	else
		progress 3 97
		if [ $rc -eq 38 ]; then
			echo -e "$(get_localized $lang $rc "$baseimage")" 1>&2
		else
			echo -e "$(get_localized $lang $rc)" 1>&2
		fi
	fi
fi
if [ $rc -eq 0 ]; then
	# modify root file system
	modify_rootfs "$unpack_directory/$squashfsdirname" "$scriptpath/modscripts"
	rc=$?
	if [ $rc -lt 2 ]; then
		rc=0
		echo -ne "$(get_localized $lang 150 $unpack_directory/$squashfsdirname)" 1>&2
		while [ 1 -eq 1 ]; do
			read abort
			if [ x$abort == xq ]; then
				echo -e "$(get_localized $lang 155)" 1>&2
				rc=1
				break
			else
				if [ ${#abort} -eq 0 ]; then
					echo -e "$msgtext_normal" 1>&2
					break
				fi
			fi
		done
	fi
fi
if [ $rc -eq 0 ]; then
	# pack new root file system
	progress 1 146
	spinner "$unpack_directory" pack_squashfs "$unpack_directory" "$unpack_directory/newroot.squashfs" $squashfs_endianess $squashfs_blocksize
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
	else
		progress 3 97
		echo -e "$(get_localized $lang $rc)" 1>&2
	fi
fi
if [ $rc -eq 0 ]; then
	# copy new root file system
	progress 1 147
	copy_new_root_filesystem "$unpack_directory/newroot.squashfs"
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
	else
		progress 3 97
		echo -e "$(get_localized $lang $rc)" 1>&2
	fi
fi
if [ $rc -eq 0 ]; then
	# switch system start partition
	progress 1 148
	switch_system_to alternative
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
		echo -e "$(get_localized $lang 149)" 1>&2
	else
		progress 3 97
		echo -e "$(get_localized $lang $rc)" 1>&2
	fi
fi
if [ $loopback_used -eq 1 ]; then
	# unmount and remove loopback partition, if it was used
	progress 1 142
	umount "$unpack_directory"
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
		progress 1 143
		rm "$loopback_host" 2>/dev/null
		rc=$?
		lbdir="${loopback_host%/loopback}"
		[ x"$lbdir" != x"$loopback_host" ] && remove_directory "$lbdir"
		if [ $rc -eq 0 ]; then
			progress 3 96
		else
			progress 3 97
			echo -e "$(get_localized $lang 57)" 1>&2
			rc=57
		fi
	else
		echo -e "$(get_localized $lang 56)" 1>&2
		rc=56
		progress 3 97
	fi
	loopback_used=0
fi
#
# temporary directories to remove
#
remove_directory "$unpack_directory"
remove_directory "$image_directory"
#
# all done ... cleanup will take place here
#
exit $rc
